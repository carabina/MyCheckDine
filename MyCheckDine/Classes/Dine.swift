import Foundation
import MyCheckCore




///MyCheckWallet is a singleton that will give you access to all of the MyCheck functionality. It has all the calls needed to manage a user's payment methods.
public class Dine{
    internal static let refreshPaymentMethodsNotification = "com.mycheck.refreshPaymentMethodsNotification"
    internal static let loggedInNotification = "com.mycheck.loggedInNotification"
    
    
    
    private static var _shared  :Dine? = Dine()
    
    ///This property points to the singleton object. It should be used for calling all the functions in the class.
    public class var shared: Dine
    {
        if let singleton = _shared
        {
          
          return singleton
        }
        _shared = Dine()
        return _shared!
    }
    
    //Used for session managment and calling server.
    internal let network = Networking.shared;
    
    
    internal init() {
      Networking.shared.configure(success: { JSON in
        if let dineConfig = JSON["dine"] as? [String:Any], let intervalNum = dineConfig["pollingInterval"] as? NSNumber{
          let interval = intervalNum.doubleValue
          if interval > 0 {
        self.poller.pollingInterval = interval
          }
        }
      }, fail: nil)

    }
    ///When activated this object polls the MyCheck server in order to fetch order updates. Call The startPolling function and set the delegate in order to receive updates. You should generally use the poller starting when a 4 digit code is created until the order is closed or canceled.
    open var poller = OrderPoller()
    
    
    //order related variables
    internal var lastOrder : Order?
    
    
    
    /// The code generated by the MyCheck server is valid for a limited time, for a specific user in a specific location. The server returns a 4 digit code to the recipient. This code, when entered into the POS enables MyCheck to sync the client with his order on the POS and can start receiving order updates and perform actions on it.
    ///
    ///    - parameter hotelId: The Id of the hotel the venue belongs to. [Optional]
    ///    - parameter restaurantId: The restaurants Id.
    ///    - parameter displayDelegate:A delegate method that will call functions in order to display and remove view controllers. When using Apple Pay the parameter must be set or else an error will be returned. This is because the user must use touch Id to approve the future payment.
    ///    - parameter applePayController: Enables the use of Apple Pay. you can equire one from the Wallet singleton.
    ///    - parameter success: A block that is called if the call complete successfully
    ///    - parameter fail: Called when the function fails for any reason
    private var a : PaymentMethodInterface? //TO-DO I added this because of a bad access crash. need to find a better way...
    open func generateCode(hotelId: String? , restaurantId: String ,displayDelegate: DisplayViewControllerDelegate? = nil, applePayController:ApplePayController? = nil, success: @escaping ((String) -> Void) , fail: ((NSError) -> Void)? ) {
        
        guard let applePayController = applePayController ,  let method = applePayController.getApplePayPaymentMethod() else {
            callGenerateCode(hotelId: hotelId, restaurantId: restaurantId, success: success, fail: fail)
            
            return
        }
        a = method

        if method.isDefault{
        method.generatePaymentToken(for: nil, displayDelegate: displayDelegate, success: {token in
            self.callGenerateCode(hotelId: hotelId, restaurantId: restaurantId, success: success, fail: fail)
        }, fail: {error in
            if let fail = fail{
                fail(error)
            }
        })
        }else{
            self.callGenerateCode(hotelId: hotelId, restaurantId: restaurantId, success: success, fail: fail)

        }
    }
    
    private func callGenerateCode(hotelId: String? , restaurantId: String , success: @escaping ((String) -> Void) , fail: ((NSError) -> Void)? ) {
        
        var params : [String: Any] = [  "restaurant_id" :  restaurantId]
        
        if let hotelId = hotelId{
            params ["hotelId"] = hotelId
        }
        if let domain = network.domain {
            let urlStr = domain + "/restaurants/api/v1/generateCode"
            
            return  network.request(urlStr, method: .post, parameters: params , success: { JSON in
                if let code = JSON["code"] as? NSNumber{
                    self.lastOrder = nil
                    success(code.stringValue)
                    
                }else{
                    if let fail = fail{
                        fail(ErrorCodes.badJSON.getError())
                    }
                }
                
            }, fail: fail)
        }else{
            if let fail = fail{
                fail(ErrorCodes.notConifgured.getError())
            }
        }
    }
  /// Returns the updated order details.
  ///
  ///    - parameter success: A block that is called if the call complete successfully. If the order returne is nil it means their is no open order.
  ///    - parameter fail: Called when the function fails for any reason
  
  public func getOrder( success: ((Order?) -> Void)? , fail: ((NSError) -> Void)? ){
 self.getOrder(order: nil, success: success, fail: fail)
  }
    
    /// Returns the updated order details.
    ///
    ///    - parameter order: The last order received. This is used in order to send the stamp (md5) an thus save the server from regenerating the order if nothing has changed.   [Optional]
    ///    - parameter success: A block that is called if the call complete successfully. If the order returne is nil it means their is no open order.
    ///    - parameter fail: Called when the function fails for any reason
    
    internal func getOrder( order: Order?, success: ((Order?) -> Void)? , fail: ((NSError) -> Void)? ){
        var orderId : String? = nil
        var stamp : String? = nil
        if let order = order {
            orderId = order.orderId
            stamp = order.stamp
        }
        if let lastOrder = lastOrder{//if not first call
            stamp = lastOrder.stamp
            orderId = lastOrder.orderId
        }
        self.callGetOrder(orderId: orderId, stamp: stamp, success: { order in
            self.lastOrder = order
            if let success = success {
                success(order)
            }
        }, fail: { error in
            if error.code == ErrorCodes.noOrderUpdate.rawValue{
                if Session.logDebugData {
                    
                    NotificationCenter.default.post(name:  Notification.Name("MyCheck comunication ouput") , object: "Success callback called")
                }
                if let success = success  {
                    success(order)
                    
                }
                return
            }
            if let fail = fail {
                fail( error)
            }
        })
    }
    
    /// Make a payment for an order
    ///
    ///   - parameter request: The details of the payment that should be charged
    ///   - parameter paymentToken: The payment method token that should be used in order to charge the user.
    public func makePayment(request: PaymentRequest , paymentToken: String){
        
    }
    
    
    /// Place an order to the POS. The items sent will be reordered and served to the user. This will only succeed if their is an open order.
    ///
    ///    - parameter items: An array of tuples where the first parameter is an Int that represents the amount of 'item' to order and the second parameter is the item to reorder.
    ///    - parameter success: A block that is called if the call complete successfully
    ///    - parameter fail: Called when the function fails for any reason
    
    public func reorderItems(items: [(amount: Int , item: Item)] , success: (() -> Void)? , fail: ((NSError) -> Void)? ){
        //creating items JSON
        var itemJSONs :[[String : Any]] = []
        for (amount , item) in items{
            guard let json = item.createReorderJSON(amount: amount)else{
                continue
            }
            
            itemJSONs.append(json)
        }
        let jsonData = try! JSONSerialization.data(withJSONObject: itemJSONs, options: JSONSerialization.WritingOptions())
        
        let jsonString = NSString(data: jsonData, encoding: String.Encoding.utf8.rawValue)! as String
        let params : [String: Any] = ["items": jsonString]
        
        
        if let domain = network.domain {
            let urlStr = domain + "/restaurants/api/v1/reorder"
            
            network.request(urlStr, method: .post, parameters: params , success: { JSON in
                if let success = success{
                    success()
                }
                
                
            }, fail: fail)
        }else{
            if let fail = fail{
                fail(ErrorCodes.notConifgured.getError())
            }
        }
        
    }
}

//MARK: - general scope functions

internal func delay(_ delay:Double, closure:@escaping ()->()) {
    let when = DispatchTime.now() + delay
    DispatchQueue.main.asyncAfter(deadline: when, execute: closure)
}

