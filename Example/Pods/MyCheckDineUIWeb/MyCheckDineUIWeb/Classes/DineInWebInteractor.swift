//
//  DineInWebInteractor.swift
//  Pods
//
//  Created by elad schiller on 8/7/17.
//  Copyright (c) 2017 __MyCompanyName__. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import MyCheckDine
import MyCheckWalletUI
import MyCheckCore
protocol DineInWebBusinessLogic
{
    
    func setupInteractor(request: DineInWeb.SetupDinein.Request)
    
    //Requests from HTML
    func getCodeRequested(request: DineInWeb.GetCode.Request)
    
    func toggleOrderDetailsPolling(request: DineInWeb.Poll.Request)
    
    func getOrderDetails(request: DineInWeb.GetOrderDetails.Request)
    
    func reorderItems(request: DineInWeb.Reorder.Request)
    
    func getPaymentMethods(request: DineInWeb.PaymentMethods.Request)
    
    func callGeneratePaymentRequest(request: DineInWeb.GeneratePayRequest.Request)
    
    func makePayment(request: DineInWeb.Pay.Request)
    
    func complete(request: DineInWeb.Complete.Request)
    
    func getFriendList(request: DineInWeb.GetFriendsList.Request)
    
    func AddAFriend(request: DineInWeb.AddAFriend.Request)
    
    func sendFeedback(request: DineInWeb.SendFeedback.Request)
    
    func callWaiter(request: DineInWeb.CallWaiter.Request)
    
    func getLocale(request: DineInWeb.getLocale.Request)
    
    func getBenefits(request: DineInWeb.getBenefits.Request)
    
    func redeemBenefits(request: DineInWeb.RedeemBenefit.Request)
    
    func displayError(request: DineInWeb.DisplayError.Request)
    
}

protocol DineInWebDataStore
{
    //var name: String { get set }
}


struct DineInWebInteractorModel{
    var tableCode: String?
    var pollerCallback: String?
    var paymentMethods: [PaymentMethodInterface]? = nil
    var order: Order? = nil
    var delegate: DineInWebViewControllerDelegate? = nil
    var locale: NSLocale? = nil
    var poller: OrderPoller? = nil
    var paymentRequest: PaymentRequest? = nil
    
}
class DineInWebInteractor: DineInWebBusinessLogic, DineInWebDataStore
{
    func displayError(request: DineInWeb.DisplayError.Request) {
        self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: request.error, callback: request.callback))
    }
    
    
    
    
    deinit {
        print("deinit DineInWebInteractor")
    }
    
    
    var presenter: DineInWebPresentationLogic?
    var worker: DineInWebWorker?
    var model : DineInWebInteractorModel  = DineInWebInteractorModel()
    
    
    func setupInteractor(request: DineInWeb.SetupDinein.Request){
        model.tableCode = request.code
        model.delegate = request.delegate
        model.locale = request.locale
        model.order = request.order
    }
    func getPaymentMethods(request: DineInWeb.PaymentMethods.Request) {
        Wallet.shared.getPaymentMethods(success: {methods in
            self.model.paymentMethods = methods
            self.presenter?.gotPaymentMethods(response: DineInWeb.PaymentMethods.Response(methods: methods, callback: request.callback))
            
        }, fail: {error in
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            
            
        })
    }
    
    func callGeneratePaymentRequest(request: DineInWeb.GeneratePayRequest.Request){
        guard let details = createPaymentDetails(request: request) else{
            let error = ErrorCodes.badJSON.getError()
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            
            return
        }
        
        
        Dine.shared.generatePaymentRequest(paymentDetails: details, success: {paymentRequest in
            
            let response: DineInWeb.GeneratePayRequest.Response = DineInWeb.GeneratePayRequest.Response(callback: request.callback, totalBeforeTax: paymentRequest.subtotal, totalTax: paymentRequest.taxAmount, totalAfterTax: paymentRequest.total, taxList: paymentRequest.taxItems , isExceedingTableTotalAmount: paymentRequest.isExceedingTableTotalAmount())
            self.model.paymentRequest = paymentRequest
            self.presenter?.generatedPaymentRequest(response: response)
            
        }, fail: {error in
            
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
        })
    }
    
    func makePayment(request: DineInWeb.Pay.Request){
        
        guard let paymentMethod = getPaymentMethod(withId: request.paymentMethodId)
            else{
                
                let error = ErrorCodes.badJSON.getError()
                
                self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
                return
        }
        guard var paymentRequest = model.paymentRequest else{
            let error = ErrorCodes.generatePaymentRequestWasNotCalled.getError()
            
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            return
            
        }
        if let tip = request.tip{
            paymentRequest.paymentDetails.tip = tip
        }
        Dine.shared.makePayment(paymentRequest: paymentRequest, paymentMethod: paymentMethod,displayDelegate: self,
                                success: { response in
                                    self.presenter?.madePayment(response: DineInWeb.Pay.Response(callback: request.callback , response: response))
                                    
        },
                                fail: {error in
                                    
                                    self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
        })
    }
    
    func reorderItems(request: DineInWeb.Reorder.Request) {
        
        Dine.shared.reorderItems(items: request.items, success: {
            
            self.presenter?.reorderedItems(response: DineInWeb.Reorder.Response(callback: request.callback))
            
        }, fail: {error in
            
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
        })
    }
    
    
    func getOrderDetails(request: DineInWeb.GetOrderDetails.Request) {
        
        if request.cache{
            getOrderDetailsFromCache(request: request)
            
        }else{
            getOrderDetailsFromServer(request: request)
        }
    }
    
    func toggleOrderDetailsPolling(request: DineInWeb.Poll.Request) {
        if model.poller == nil {
            model.poller = Dine.shared.createNewPoller(delegate: self)
        }
        
        guard let poller = model.poller else {
            return
        }
        
        model.pollerCallback = request.callback
        
        if request.pollingOn{
            poller.startPolling()
        }else{
            poller.stopPolling()
        }
    }
    
    
    
    
    
    
    
    
    func getCodeRequested(request: DineInWeb.GetCode.Request){
        if let code = model.tableCode{
            presenter?.presentTableCode(response: DineInWeb.GetCode.Response(code: code, callback: request.callback))
            return
        }
        self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: ErrorCodes.orderIsOpen.getError(), callback: request.callback))
        
    }
    
    
    func complete(request: DineInWeb.Complete.Request) {
        guard let delegate = model.delegate else {
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: ErrorCodes.SDKInternalError.getError(), callback: request.callback))
            return
        }
        if let poller = model.poller{
            poller.stopPolling()
            model.poller = nil
            
        }
        self.presenter?.complete(response: DineInWeb.Complete.Response(reason: request.reason, callback: request.callback, delegate: delegate, order: model.order))
    }
    
    
    func getFriendList(request: DineInWeb.GetFriendsList.Request){
        Dine.shared.getFriendsListAtOpenTable(success: { friendsList in
            let response = DineInWeb.GetFriendsList.Response(callback: request.callback, friends: friendsList)
            self.presenter?.gotFriendList(response: response)
        }, fail: {error in
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            
        })
    }
    
    func AddAFriend(request: DineInWeb.AddAFriend.Request){
        
        Dine.shared.addFriendToOpenTable(friendCode: request.code, success: {
            let response = DineInWeb.AddAFriend.Response(callback: request.callback)
            self.presenter?.addedFriend(response: response)
        }, fail: {error in
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            
        })
    }
    
    func sendFeedback(request: DineInWeb.SendFeedback.Request){
        
        Dine.shared.sendFeedback(for: request.orderId, stars:request.stars, comment: request.comment, success: {
            self.presenter?.sentFeedback(response: DineInWeb.SendFeedback.Response(callback: request.callback))
        }, fail: {error in
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            
        })  }
    
    func callWaiter(request: DineInWeb.CallWaiter.Request){
        Dine.shared.callWaiter(success: {
            self.presenter?.calledWaiter(response: DineInWeb.CallWaiter.Response(callback: request.callback))
        }, fail: {error in
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
        })
    }
    
    func getLocale(request: DineInWeb.getLocale.Request){
        guard let locale = model.locale else{
            return
        }
        self.presenter?.gotLocale(response: DineInWeb.getLocale.Response(callback: request.callback, locale: locale))
    }
    
    func getBenefits(request: DineInWeb.getBenefits.Request) {
        
        Benefits.getBenefits(restaurantId: request.restaurantId, success: {benefits in
            
            self.presenter?.gotBenefits(response: DineInWeb.getBenefits.Response(callback: request.callback, benefits: benefits))
            
        }, fail: {error in
            
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
        })    }
    
    
    func redeemBenefits(request: DineInWeb.RedeemBenefit.Request) {
        var restaurantId = request.restaurantId
        
        if let order =  model.order,
            restaurantId == nil {
            
            restaurantId = order.restaurantId
        }
        Benefits.redeem(benefit: request.benefit, restaurantId: restaurantId, success: {
            let response = DineInWeb.RedeemBenefit.Response(callback: request.callback)
            self.presenter?.redeemedBenefits(response: response)
        }, fail: {error in
            
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            
            
        })
    }
    
}

// MARK - private methods
fileprivate extension DineInWebInteractor{
    
    
    func getOrderDetailsFromServer(request: DineInWeb.GetOrderDetails.Request) {
        
        Dine.shared.getOrder(success: {order in
            self.model.order = order
            self.presenter?.gotOrder(response:
                DineInWeb.GetOrderDetails.Response(order: order, callback: request.callback))
            
        }, fail: {error in
            
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: error, callback: request.callback))
            
            
        })
        
    }
    
    func getOrderDetailsFromCache(request: DineInWeb.GetOrderDetails.Request){
        guard let order = model.order else{
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: ErrorCodes.noCachedOrder.getError(), callback: request.callback))
            
            return
        }
        
        self.presenter?.gotOrder(response:
            DineInWeb.GetOrderDetails.Response(order: order, callback: request.callback))
        
    }
    
    func getPaymentMethod(withId ID: String) -> PaymentMethodInterface?{
        guard let methods = self.model.paymentMethods,
            let indexOfMethod = methods.index(where: { $0.ID == ID })
            else{
                return nil
        }
        return methods[indexOfMethod]
        
    }
    
    func createPaymentDetails(request: DineInWeb.GeneratePayRequest.Request) -> PaymentDetails? {
        guard let order = self.model.order else{
            return nil
        }
        
        switch request.payFor {
        case .amount(let amount):
            return PaymentDetails(order: order, amount: amount, tip: request.tip)
        case .items(let items):
            return PaymentDetails(order: order, items: items, tip: request.tip)
        case .fullAmount:
            return PaymentDetails(order: order, tip: request.tip)
        }
        
    }
    
    
    
}

extension DineInWebInteractor: OrderPollerDelegate{
    ///Called when the order was updated.
    ///
    /// - parameter order: The up to date order or nil if their is n order.
    func orderUpdated(order: Order?) {
        
        self.model.order = order
        
        guard let callback =  model.pollerCallback else{
            return
        }
        if let order = order{
            self.presenter?.orderUpdated(response: DineInWeb.Poll.Response.success(order: order, callback: callback))
        }else{
            self.presenter?.presentFailError(response: DineInWeb.FailResponse(error: ErrorCodes.noOpenTable.getError(), callback: callback))
            
        }
    }
    
    func failingToReceiveUpdates(lastReceivedError: NSError , failCount:Int){
        guard let callback =  model.pollerCallback else{
            return
        }
        self.presenter?.orderUpdated(response: DineInWeb.Poll.Response.fail(error: lastReceivedError ,callback:  callback))
        
    }
    
    
}

extension DineInWebInteractor: DisplayViewControllerDelegate{
    func display(viewController: UIViewController) {
        presenter?.displayApplePayViewController(response: DineInWeb.DisplayApplePayViewController.Response(viewController: viewController, show: true))
    }
    
    func dismiss(viewController: UIViewController) {
        presenter?.displayApplePayViewController(response: DineInWeb.DisplayApplePayViewController.Response(viewController: viewController, show: false))

    }
    
    
    
}
